
#pragma once

#ifndef __IC3_GRAPHICS_GCI_PIPELINE_STATE_DESCRIPTOR_H__
#define __IC3_GRAPHICS_GCI_PIPELINE_STATE_DESCRIPTOR_H__

#include "PipelineStateCommon.h"

namespace Ic3::Graphics::GCI
{

	class DynamicDescriptorDriverState;

	template <typename TPDriverDataType>
	class TDynamicDescriptorDriverState;

	/*
	 *
	 */
	class IC3_GRAPHICS_GCI_CLASS PipelineStateDescriptor : public GPUDeviceChildObject
	{
		friend class PipelineStateController;
		friend class PipelineStateDescriptorManager;

	public:
		PipelineStateDescriptor( GPUDevice & pGPUDevice );
		virtual ~PipelineStateDescriptor();

		/**
		 * Queries the type of the descriptor, expressed as one of the possible values defined in
		 * EPipelineStateDescriptorType enumeration. Implemented by the child descriptor classes.
		 * 
		 * @return The dynamic type of this descriptor instance.
		 * @see EPipelineStateDescriptorType
		 */
		CPPX_ATTR_NO_DISCARD virtual EPipelineStateDescriptorType GetDescriptorType() const noexcept = 0;

		/**
		 * @brief Returns true if this descriptor is a cached descriptor, or false otherwise.
		 * 
		 * Cached descriptors are descriptor types which are not created directly by the factory,
		 * but through an additional cache, managed by DescriptorManager. Those descriptors also
		 * cannot be created with an explicitly-specified ID, but got their IDs generated by the
		 * mentioned cache. This is done for two purposes:
		 * - Descriptors don't have to be managed by the GCI client: no checking for dulicated
		 *   configs, no validation of the IDs. Everything gets done automatically by the API.
		 * - Descriptors are automatically re-used: whenever a descriptor is requested and another
		 *   descriptor for the same config is already in the cache, the cached descriptor will be
		 *   returned immediately. This greatly reduces the memory usage and allows us to efficiently
		 *   filter out and minimize pipeline state changes. There is also a speed improvement in
		 *   comparison: to check if two DepthStencilStateDescriptors are equal, we need to check
		 *   their addresses and avoid comparing their internal configuration (which is API-specific).
		 * 
		 * @return 
		 */
		CPPX_ATTR_NO_DISCARD virtual bool IsCachedDescriptorType() const noexcept = 0;

		/**
		 * Returns true if this descriptor is a dynamic descriptor. Dynamic descriptor is a descriptor class
		 * that does not contain any API-specific properties, i.e. it is defined fully at the GCI abstraction level
		 * and their configuration can be updated on the fly, without re-creating the descriptor via GPUDevice.
		 * The only exception to these descriptors being API-agnostic is that they contain an additional,
		 * descriptor- and API-specific data that stores the cached state managed and updated by the driver.
		 * This reduces the overhead of translating a generic specification from dynamic descriptors each time
		 * they are bound to the pipeline.
		 *
		 * How this works:
		 * - Each dynamic descriptor class adds an extra RAII pointer that holds the additional driver data.
		 *   This pointer stores the data as the base DynamicDescriptorDriverState class.
		 * - When a dynamic descriptor is bound to the pipeline, driver initializes that data, translates
		 *   the descriptor's config to its native format and stores the translated config inside it.
		 * - Each time the descriptor is updated (its config changes), driver updates the cached state accordingly.
		 * There is also an additional helper class provided: PipelineStateDescriptorDynamic which implements
		 * the functionality (see below) required for dynamic descriptors to work properly.
		 *
		 * @note The following classes are implementations of dynamic descriptors:
		 * - VertexSourceBindingDescriptorDynamic
		 * - RenderPassDescriptorDynamic
		 * - RenderTargetBindingStateDescriptorDynamic
		 * @return
		 */
		CPPX_ATTR_NO_DISCARD virtual bool IsDynamicDescriptor() const noexcept;

		//doc
		CPPX_ATTR_NO_DISCARD pipeline_state_descriptor_id_t GetDescriptorID() const noexcept;

		//doc
		CPPX_ATTR_NO_DISCARD pipeline_state_descriptor_id_t HasValidDescriptoIDSet() const noexcept;

	protected:
		using descriptor_internal_flags_value_t = uint16;

		void SetInternalFlags( cppx::bitmask<descriptor_internal_flags_value_t> pInternalFlags ) noexcept;

		void ResetInternalFlags( cppx::bitmask<descriptor_internal_flags_value_t> pInternalFlags ) noexcept;

		bool CheckInternalFlags( cppx::bitmask<descriptor_internal_flags_value_t> pInternalFlags ) const noexcept;

		cppx::bitmask<descriptor_internal_flags_value_t> GetInternalFlags() const noexcept;

	friendapi( private ):
		/**
		 * @brief 
		 */
		void SetDescriptorID( pipeline_state_descriptor_id_t pDescriptorID ) noexcept;

	private:
		pipeline_state_descriptor_id_t _descriptorID;
		cppx::bitmask<descriptor_internal_flags_value_t> _internalFlags;
	};

	inline pipeline_state_descriptor_id_t PipelineStateDescriptor::GetDescriptorID() const noexcept
	{
		return _descriptorID;
	}

	inline pipeline_state_descriptor_id_t PipelineStateDescriptor::HasValidDescriptoIDSet() const noexcept
	{
		return CXU::IsPipelineStateDescriptorIDValid( _descriptorID );
	}

	inline void PipelineStateDescriptor::SetDescriptorID( pipeline_state_descriptor_id_t pDescriptorID ) noexcept
	{
		_descriptorID = pDescriptorID;
	}

	/**
	 * @brief 
	 * @tparam TPBaseDescriptor 
	 */
	template <typename TPBaseDescriptor>
	class CachedPipelineStateDescriptor : public TPBaseDescriptor
	{
	public:
		CachedPipelineStateDescriptor( GPUDevice & pGPUDevice )
		: TPBaseDescriptor( pGPUDevice )
		{}

		virtual ~CachedPipelineStateDescriptor() = default;

		CPPX_ATTR_NO_DISCARD virtual bool IsCachedDescriptorType() const noexcept override final
		{
			return true;
		}
	};
	
	/**
	 * @brief 
	 * @tparam TPBaseDescriptor 
	 */
	template <typename TPBaseDescriptor>
	class NonCachedPipelineStateDescriptor : public TPBaseDescriptor
	{
	public:
		NonCachedPipelineStateDescriptor( GPUDevice & pGPUDevice )
		: TPBaseDescriptor( pGPUDevice )
		{}

		virtual ~NonCachedPipelineStateDescriptor() = default;

		CPPX_ATTR_NO_DISCARD virtual bool IsCachedDescriptorType() const noexcept override final
		{
			return false;
		}
	};

	/**
	 * @brief 
	 * @tparam TPBaseDescriptor 
	 */
	template <typename TPBaseDescriptor>
	class HW3DPipelineStateDescriptor : public TPBaseDescriptor
	{
	public:
		template <typename... TPArgs>
		HW3DPipelineStateDescriptor( TPArgs && ...pArgs )
		: TPBaseDescriptor( std::forward<TPArgs>( pArgs )... )
		{}
	};

} // namespace Ic3::Graphics::GCI

#endif // __IC3_GRAPHICS_GCI_PIPELINE_STATE_DESCRIPTOR_H__
